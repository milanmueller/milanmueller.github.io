<!DOCTYPE html>
<html lang="en" class="dark light">

    <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="base" content="https:&#x2F;&#x2F;milanmueller.de">

    

    
    
    
        <title>
            
                Learning Haskell, Chapter 1 - What the hell is a monad?
            
        </title>

        
            <meta property="og:title"
                  content="Learning Haskell, Chapter 1 - What the hell is a monad?" />
        
    

    
        
    

    
        
    

    
    

    
    
        <link href=https://milanmueller.de/fonts.css rel="stylesheet" />
    

    
    

    
    

    
    

    
    

    
        
            <script>
            MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };
            </script>
        
        <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
        </script>
    

    
    <link rel="alternate"
          type="application/atom+xml"
          title=""
          href="https://milanmueller.de/atom.xml">


    
    
        <link rel="stylesheet"
              type="text/css"
              href="https://milanmueller.de/theme/light.css" />
        <link id="darkModeStyle"
              rel="stylesheet"
              type="text/css"
              href="https://milanmueller.de/theme/dark.css" />
    

    <!-- Set the correct theme in the script -->

    
        <script src=https://milanmueller.de/js/themetoggle.js></script>

        
            <script>setTheme(getSavedTheme());</script>
        
    


    <link rel="stylesheet"
          type="text/css"
          media="screen"
          href="https://milanmueller.de/main.css" />

    

    
        <script defer
                src="https://milanmueller.de/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e"></script></head>


    <body>
        <div class="content">
            <header>
    <div class="main">
        
            <a href=https:&#x2F;&#x2F;milanmueller.de></a>
        


        <div class="socials">
            
                <a rel="me" href="https:&#x2F;&#x2F;github.com&#x2F;milanmueller&#x2F;" class="social">
                    <img alt="github"
                         src="https://milanmueller.de/icons/social/github.svg">
                </a>
            
        </div>
    </div>

    <nav>
        
            <a href=https://milanmueller.de style="margin-left: 0.25em">~&#x2F;</a>
        
            <a href=https://milanmueller.de/posts style="margin-left: 0.25em">~&#x2F;posts</a>
        
            <a href=https://milanmueller.de/about style="margin-left: 0.25em">~&#x2F;about</a>
        

        
            <button id="search-button"
                    class="search-button"
                    title="$SHORTCUT to open search">
                <img src="https://milanmueller.de/icons/search.svg"
                     alt="Search"
                     class="search-icon">
            </button>

            <div id="searchModal"
                 class="search-modal js"
                 role="dialog"
                 aria-labelledby="modalTitle">
                <div id="modal-content">
                    <h1 id="modalTitle" class="page-header">Search</h1>
                    <div id="searchBar">
                        <input id="searchInput"
                               role="combobox"
                               autocomplete="off"
                               spellcheck="false"
                               aria-expanded="false"
                               aria-controls="results-container"
                               placeholder="Search..." />
                        <button id="clear-search" class="clear-button" title="Clear search">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960">
                                <path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z" />
                            </svg>
                        </button>
                    </div>
                    <div id="results-container">
                        <div id="results-info">
                            <span id="zero_results" style="display: none;">No results</span>
                            <span id="one_result" style="display: none;">1 result</span>
                            <span id="many_results" style="display: none;">$NUMBER results</span>
                        </div>
                        <div id="results" role="listbox"></div>
                    </div>
                </div>
            </div>
        

        
            <a id="dark-mode-toggle"
               onclick="toggleTheme(); event.preventDefault();"
               href="#">
                <img src="https://milanmueller.de/icons/sun.svg"
                     id="sun-icon"
                     style="filter: invert(1)"
                     alt="Light" />
                <img src=https://milanmueller.de/icons/moon.svg id="moon-icon" alt="Dark" />
            </a>

            <!-- Inititialize the theme toggle icons -->
            <script>updateItemToggleTheme()</script>
        
    </nav>
</header>


            
            
    
    <main>
        <article>
            <div class="title">
                
                
    <div class="page-header">
        Learning Haskell, Chapter 1 - What the hell is a monad?<span class="primary-color" style="font-size: 1.6em">.</span>
    </div>


                <div class="meta">
                    
                        Posted on <time>2025-08-29</time>
                    

                    

                    

                    :: 2710 Words

                    
                    
                        <span class="tags-label">:: Tags:</span>
                        <span class="tags">
                                <a href="https://milanmueller.de/tags/programming/"
                                   class="post-tag">programming</a>
                                ,
                            
                                <a href="https://milanmueller.de/tags/learning/"
                                   class="post-tag">learning</a>
                                ,
                            
                                <a href="https://milanmueller.de/tags/haskell/"
                                   class="post-tag">Haskell</a>
                                
                            
                        </span>
                    

                    
                    
                        
                        
                            
                        

                        
                    

                    

                </div>
            </div>

            

            
            

            <section class="body">
                <h1 id="learning-haskell-chapter-1-what-the-hell-is-a-monad"><a class="zola-anchor" href="#learning-haskell-chapter-1-what-the-hell-is-a-monad" aria-label="Anchor link for: learning-haskell-chapter-1-what-the-hell-is-a-monad">Learning Haskell, Chapter 1 - What the hell is a monad?</a></h1>
<p><em>Note: This is not a tutorial, it is some kind of progress report about my personal experience with trying to learn the programming language <a href="https://www.haskell.org/">Haskell</a>.</em></p>
<p><em>Note: This is a first version of the post without any proofreading. I will go over it again and might do significant amounts of rewriting. Once I'm done, I will remove this second Note.</em></p>
<h2 id="introduction"><a class="zola-anchor" href="#introduction" aria-label="Anchor link for: introduction">Introduction</a></h2>
<h3 id="the-motivation"><a class="zola-anchor" href="#the-motivation" aria-label="Anchor link for: the-motivation">The Motivation</a></h3>
<p>In some of the university lectures I had the chance to attend, I was introduced to the idea of functional programming.
While being less intuitive than imperative languages, I found programming in a functional way to be quite satisfying compared to writing for loops all the time.
Somehow the abstract way of thinking which functional programming necessitates tickles similar parts of my brain as videos of hydraulic presses crushing stuff do.</p>
<p>I have also been wanting to do a personal programming project for some time, so I figured I might combine that with my curiosity for functional programming and try to solve some more complex problems than the usual toy programs from university lectures (which is not to say that those were too easy, what I mean by <em>complexity</em> here, is the size of the program and also its real world usability rather than whether they are hard or easy to solve.)</p>
<h3 id="the-project"><a class="zola-anchor" href="#the-project" aria-label="Anchor link for: the-project">The Project</a></h3>
<p>Here's the goal: I want to implement a very simple kind of <a href="https://en.wikipedia.org/wiki/Time_series_database">Time series database</a>. <br />
Now, calling what I'm planning to do a database might be a bit far fetched, so let's go with a more concrete description of my goal:</p>
<ul>
<li>The user should be able to define <em>metrics</em>. A <em>metric</em> is a tuple <code>(name, type)</code>, where <code>name</code> is the name of the metric and <code>type</code> is, well, a datatype like number, flag (boolean), or some custom "one of" (i.e. enum) type.
<ul>
<li>I will not exactly fix the available types now, maybe I discover some other interesting types to support in the future.</li>
</ul>
</li>
<li>The user should then be able to track these metrics, i.e., insert a concrete value for a defined metric alongside a timestamp.</li>
<li>The user should be able to fetch stored data for the metrics, optionally with applying some aggregation functions that are sensible w.r.t the respective datatype - this is probably where the bulk of the work is going to come from.</li>
</ul>
<p>For now, inputting data should be possible through a command line tool, but maybe I will also implement a lightweight web api, cause that's what the cool kids do, right?</p>
<p>I want to implement all of this on a relatively low level. Of course I could use an existing database system and essentially write a wrapper around it, but where is the fun in that?</p>
<p>My language of choice is going to be Haskell, since I've already learned some Haskell at uni and it seems to be quite representative of the "functional experience".</p>
<h3 id="where-i-m-coming-from"><a class="zola-anchor" href="#where-i-m-coming-from" aria-label="Anchor link for: where-i-m-coming-from">Where I'm coming from</a></h3>
<p>While I'm not a first-time Haskell type of beginner, I'm definitely a beginner in Haskell programming and functional programming in general.
To be more precise, here are two statements of my current understanding of Haskell:</p>
<ul>
<li>I can understand the type signature of the bind operator <code>&gt;&gt;=</code> when I look at it.</li>
<li>Five minutes later, I again have no clue what a monad is supposed to be.</li>
</ul>
<h3 id="personal-goals"><a class="zola-anchor" href="#personal-goals" aria-label="Anchor link for: personal-goals">Personal Goals</a></h3>
<ul>
<li>I want to put some concepts I've heard (like monads) of into practice within a real project.</li>
<li>I finally want to get around to actually following through on one of my many ideas for personal projects.</li>
<li>I want to "properly" write a piece of software. Even though my goal is not to write a production ready postgresql replacement, I would still like to do things as right as I can. The process of creating this thing should be as close to "real world" programming as possible. <br />
Little spoiler: I'm going to go with a "get hands dirty, cleanup later" kind of approach here.
While I do want to do things properly, I will come back to testing and documentation later and focus on actually writing some code first.</li>
</ul>
<h3 id="methodology"><a class="zola-anchor" href="#methodology" aria-label="Anchor link for: methodology">Methodology</a></h3>
<p>This is a personal blog that no one other than me is ever going to read, so choosing "methodology" as the <code>h3</code> heading here seems really overkill. <br />
Still, I want to to be transparent about how I am approaching this. Especially in the era of "vibe coding".</p>
<ul>
<li>I do not have llm-based autocomplete in my editor. The Haskell language server is all I'm using on that front. My editor of choice is <a href="https://helix-editor.com/">Helix</a>.</li>
<li>I will ask ChatGPT or gemini cli whenever I get stuck with something for a longer period of time. I do think that there is something to gain from this approach even if it sometimes means to just do whatever an llm tells you. I can still use the generated stuff to have something that works and use it to learn why and how to then improve upon it.</li>
</ul>
<p>I made the project public on <a href="https://github.com/milanmueller/tasdb">Github</a> so that if anyone ever reads this, they could have a look at the source.</p>
<h2 id="getting-started"><a class="zola-anchor" href="#getting-started" aria-label="Anchor link for: getting-started">Getting started</a></h2>
<p>When I was younger, I tried to learn to draw. One of the hardest things about that, I felt like, was the initial hurdle of getting started with a drawing.
It felt like if I placed the first line of the initial sketch at the wrong position, the entire piece was doomed to be a complete failure.
Maybe this is a form of procrastination, maybe it is a form of perfectionism, or maybe both.</p>
<p>When I tried to get into some other project with languages I feel like I'm supposed to know (like Python, Java or to some degree C++ in my case), I would struggle with a similar thing.
Maybe this could be attributed to some ideas from oop, but I always feel like unless I find the perfect representation, class hierarchy, UML diagram or whatever right away, the project was going to end in an utter mess.</p>
<p>With Haskell, it seems I don't suffer from that. Maybe it's because I don't feel like I'm supposed to know what I'm doing in the first place.</p>
<p>A straight forward way to start this project seemed to be some datatypes to represent my database thingy. Here is what I came up with:</p>
<pre data-lang="Haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-Haskell "><code class="language-Haskell" data-lang="Haskell"><span style="color:#65737e;">-- from `src/Core.hs`
</span><span style="color:#b48ead;">type </span><span style="color:#d08770;">MetricName </span><span>= </span><span style="color:#d08770;">String
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">MetricType </span><span>= </span><span style="color:#d08770;">TInt </span><span>| </span><span style="color:#d08770;">TBool </span><span>| </span><span style="color:#d08770;">TEnum</span><span> (</span><span style="color:#d08770;">HashSet String</span><span>)
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">MetricValue </span><span>= </span><span style="color:#d08770;">VInt Int </span><span>| </span><span style="color:#d08770;">VBool Bool </span><span>| </span><span style="color:#d08770;">VEnum String
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">DataPoint </span><span>= </span><span style="color:#d08770;">DataPoint</span><span> { value :: </span><span style="color:#d08770;">MetricValue</span><span>, time :: </span><span style="color:#d08770;">UTCTime</span><span> }
</span></code></pre>
<p>One thing I'd like to point out here is how easily this follows from my rough ideas up in <a href="https://milanmueller.de/posts/learning-haskell-01/#the-project"># The Project</a>.
In oop languages this is already the point where I would maybe be wasting a lot of time thinking about class hierarchies and how to encapsulate this data properly but in Haskell I feel like I can just type down whatever comes to mind (at least for now).</p>
<p>The choice of the proper datatype for timestamps is apparently not trivial, according to <a href="https://wiki.haskell.org/Time">this article</a>, but I decided to not worry too much about it for now and just pick <code>UTCTime</code> here as I think think it would not be too hard to change this in the future if I ever felt like I need to.</p>
<p>Now to actually store data, we of course need some kind of representation of "state".
To get started, I first want to store everything in memory and then tackle the hard part of serializing data, writing it to, and reading it from disk later on.
My memory allocated state looks like this:</p>
<pre data-lang="Haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-Haskell "><code class="language-Haskell" data-lang="Haskell"><span style="color:#65737e;">-- from `src/Core.hs`
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">DBState </span><span>= </span><span style="color:#d08770;">DBState
</span><span>  { types :: </span><span style="color:#d08770;">Map MetricName MetricType
</span><span>  , values :: </span><span style="color:#d08770;">Map MetricName</span><span> [</span><span style="color:#d08770;">DataPoint</span><span>]
</span><span>  }
</span></code></pre>
<p>Note that <code>Data.Map</code>, which implements a Hashmap, is imported as <code>Map</code> here. If that's considered bad practice, I apologize.</p>
<p>One thing to note here, is that these six lines of code are already enough to represent some kind of <em>insane</em> state.
Lets say we have
$$
\begin{align*}
\textit{types} &amp;= \lbrace \textit{foo} \rightarrow \texttt{bool}, \textit{bar} \rightarrow \texttt{int} \rbrace \\
\textit{values} &amp;= \lbrace \textit{foo} \rightarrow [1, 2, 3] \rbrace
\end{align*}
$$
<em>Note: I've omitted the timestamps here for simplicity.</em></p>
<p>This state is legal w.r.t. our defined Haskell types, but it is a state that does not make sense, since <em>foo</em> is supposed to collect boolean values, not integer values. The type checker will not save us from such a state unfortunately.</p>
<p>Maybe there exists some kind of Haskell magic to prevent such states just through the type system, but if so, I am not aware of it (yet).</p>
<p>From what I've heard, the <code>Either</code> type is a decent way of encapsulating potentially erroneous states, so I elect to use that to differentiate between sane and insane states.</p>
<p>I had gemini create some sensible Error types for me which look like this:</p>
<pre data-lang="Haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-Haskell "><code class="language-Haskell" data-lang="Haskell"><span style="color:#b48ead;">data </span><span style="color:#d08770;">DBError
</span><span>  = </span><span style="color:#d08770;">MetricNotFound MetricName
</span><span>  | </span><span style="color:#d08770;">TypeMismatch MetricName MetricType MetricValue
</span><span>  | </span><span style="color:#d08770;">InvalidEnumValue MetricName String</span><span> (</span><span style="color:#d08770;">HashSet String</span><span>)
</span><span>  | </span><span style="color:#d08770;">MetricAlreadyExists MetricName
</span><span>  | </span><span style="color:#d08770;">InvalidInput String
</span></code></pre>
<p>Another predefined type that might be useful to us here is the <code>State</code> type, since we are dealing with, well, some kind of state.</p>
<p>Using <code>Either</code> and <code>State</code> gives raise to the following monad stack (at least I hope that's what this thing is called):</p>
<pre data-lang="Haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-Haskell "><code class="language-Haskell" data-lang="Haskell"><span style="color:#b48ead;">type </span><span style="color:#d08770;">DBMonad </span><span>= </span><span style="color:#d08770;">StateT DBState</span><span> (</span><span style="color:#d08770;">Either DBError</span><span>)
</span></code></pre>
<p>I'm using the <code>mtl</code> package here to stack these monads, though I have to say I'm not sure if this could also be achieved with <code>transformers</code>.
I might come back to this question at some point, to get a deeper understanding of monads and the workings of their stacking ^^.</p>
<p>What I do believe to know is that this scenario (state and errors) is one of the use cases of monads, so I'm just trying to use them and see where that's going to lead me :)</p>
<h2 id="state-is-evil-so-lets-change-it"><a class="zola-anchor" href="#state-is-evil-so-lets-change-it" aria-label="Anchor link for: state-is-evil-so-lets-change-it">State is evil - so lets change it</a></h2>
<p>Again with the help of gemini (since I'm just not used to monads enough), I created some functions to modify my little state representation.
The most interesting one is probably <code>addDataPoint</code>:</p>
<pre data-lang="Haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-Haskell "><code class="language-Haskell" data-lang="Haskell"><span style="color:#8fa1b3;">addDataPoint </span><span style="color:#b48ead;">:: MetricName -&gt; MetricValue -&gt; UTCTime -&gt; DBMonad </span><span>()
</span><span>addDataPoint name val timestamp = </span><span style="color:#b48ead;">do
</span><span>  mtype &lt;- getMetricType name
</span><span>  </span><span style="color:#b48ead;">case</span><span> validateValue mtype val name </span><span style="color:#b48ead;">of
</span><span>    </span><span style="color:#d08770;">Left</span><span> err -&gt; lift $ </span><span style="color:#d08770;">Left</span><span> err
</span><span>    </span><span style="color:#d08770;">Right () </span><span>-&gt; </span><span style="color:#b48ead;">do
</span><span>      s &lt;- </span><span style="color:#d08770;">Control</span><span>.</span><span style="color:#d08770;">Monad</span><span>.</span><span style="color:#d08770;">State</span><span>.get
</span><span>      </span><span style="color:#b48ead;">let</span><span> oldPoints = </span><span style="color:#d08770;">Map</span><span>.findWithDefault </span><span style="color:#d08770;">[]</span><span> name (values s)
</span><span>          newPoint = </span><span style="color:#d08770;">DataPoint</span><span> val timestamp
</span><span>          newPoints = newPoint : oldPoints
</span><span>      </span><span style="color:#d08770;">Control</span><span>.</span><span style="color:#d08770;">Monad</span><span>.</span><span style="color:#d08770;">State</span><span>.put $ s{values = </span><span style="color:#d08770;">Map</span><span>.insert name newPoints (values s)}
</span></code></pre>
<p>The purpose of the used helper function <code>getMetricType name</code> is quite self explanatory - it checks if <code>name</code> is an existing metric and returns it's type if so.</p>
<p>What I would like to point out here, is how we don't have to check whether it returns an error since the potential error is encoded in our monad stack <code>DBMonad</code>, similarly to how we might be able to use the <code>?</code> operator in rust.</p>
<p>The other helper function <code>validateType</code> checks if the value of our new data type is compatible with the respective metric's type and might also generate a fitting error, if not.</p>
<p>In addition to <code>addDataPoint</code>, there are also two other functions which I will not show here, but they are implemented in a similar manner:</p>
<ul>
<li><code>addMetric</code> - to define new metrics. This one might produce an error if a metric already exists.</li>
<li><code>deleteMetric</code> - to delete metrics. It will produce an error if the given metric does not exist, since some kind of idempotent deletion, if desired, should probably be "opt in" at a higher level.</li>
</ul>
<h2 id="handling-user-input"><a class="zola-anchor" href="#handling-user-input" aria-label="Anchor link for: handling-user-input">Handling user input</a></h2>
<p>We want to support user interaction. For now through a little cli tool.
Since state only lives in memory until we do proper databasing, I decided to create a little repl for this.</p>
<p>This turned out a bit challenging for me and after some attempts with using a specialized library for cli argument parsing, I decided to use <a href="https://hackage.haskell.org/package/parsec">Parsec</a> for parsing my repl's input and then translating that into calls to my previously created functions.</p>
<p>Maybe in the future I will go back to this step and do the parsing myself, since I think this might be a nice learning challenge.</p>
<p>Another though of mine is that Parsec, being a <em>monadic</em> parsing library, might be a bit overkill and using an <em>applicative</em> parser would be sufficient for this use case.
For now however, I wanted something that <em>just works</em> and Parsec did not disappoint me.</p>
<p>We want to be able to parse two commands for now:</p>
<ul>
<li><code>metric add "name" &lt;type&gt;</code></li>
<li><code>value insert "name" "value"</code></li>
</ul>
<p>To represent these two commands, I came up with the following little grammar for my commands:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>&lt;ident&gt; ::= &lt;string&gt;
</span><span>&lt;val&gt; ::= &lt;integer&gt; | true | false | &lt;string&gt;
</span><span>&lt;type&gt; ::= int | bool | enum [&lt;string&gt; (,&lt;string&gt;)*]
</span><span>&lt;mcmd&gt; ::= add &lt;ident&gt; &lt;type&gt;
</span><span>&lt;vcmd&gt; ::= insert &lt;ident&gt; &lt;val&gt;
</span><span>&lt;cmd&gt; ::= metric &lt;mcmd&gt; | value &lt;vcmd&gt;
</span></code></pre>
<p>I hope it's clear how this grammar can be used to build our two commands, even though it probably can not hold up to any standards of formal correctness.
Our enum type should be definable like <code>metric add "colors" enum ["red", "green", "blue"]</code>, that's what the weird pseudo-regex for <code>&lt;type&gt;</code> is supposed to encode.</p>
<p>Of course I also tried to design this little grammar in a way such that it could easily be extended in the future.</p>
<p>In Haskell, the AST we want to parse into, follows directly from the grammar above:</p>
<pre data-lang="Haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-Haskell "><code class="language-Haskell" data-lang="Haskell"><span style="color:#b48ead;">data </span><span style="color:#d08770;">Val </span><span>= </span><span style="color:#d08770;">VStr String </span><span>| </span><span style="color:#d08770;">VInt Int </span><span>| </span><span style="color:#d08770;">VBool Bool 
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Type </span><span>= </span><span style="color:#d08770;">TInt </span><span>| </span><span style="color:#d08770;">TBool </span><span>| </span><span style="color:#d08770;">TEnum</span><span> [</span><span style="color:#d08770;">String</span><span>]
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">MetricCmd </span><span>= </span><span style="color:#d08770;">Add String Type
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">ValueCmd </span><span>= </span><span style="color:#d08770;">Insert String Val
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Cmd </span><span>= </span><span style="color:#d08770;">MCmd MetricCmd </span><span>| </span><span style="color:#d08770;">VCmd ValueCmd
</span></code></pre>
<p>With Parsec, we can define a lexer with one simple function:</p>
<pre data-lang="Haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-Haskell "><code class="language-Haskell" data-lang="Haskell"><span style="color:#8fa1b3;">lexer </span><span style="color:#b48ead;">:: TokenParser </span><span>()
</span><span>lexer = makeTokenParser style </span><span style="color:#b48ead;">where
</span><span>  style = emptyDef
</span><span>    { reservedNames = [&quot;</span><span style="color:#a3be8c;">metric</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">value</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">insert</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">int</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">bool</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">enum</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">true</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">false</span><span>&quot;]
</span><span>    , reservedOpNames = [&quot;</span><span style="color:#a3be8c;">[</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">]</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">,</span><span>&quot;]
</span><span>    }
</span></code></pre>
<p>I should note that none of what I'm doing here is supposed to be best practice. I'm using Parsec for the first time and I like to use a "try until it works" approach when learning new things.</p>
<p>For each type of our AST, we create a parsing function. I won't include all of them here (the complete source is on <a href="https://github.com/milanmueller/tasdb">github</a>), but as an example, here is the parser for our metric types (this one should be able to parse <code>int</code>, <code>bool</code> or custom enums <code>enum ["option1", "option2", "option3"]</code>):</p>
<pre data-lang="Haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-Haskell "><code class="language-Haskell" data-lang="Haskell"><span style="color:#8fa1b3;">parseType </span><span style="color:#b48ead;">:: Parser Type
</span><span>parseType = parseIntType &lt;|&gt; parseBoolType &lt;|&gt; parseEnumType
</span><span>  </span><span style="color:#b48ead;">where
</span><span>    parseIntType = reserved lexer &quot;</span><span style="color:#a3be8c;">int</span><span>&quot; &gt;&gt; return </span><span style="color:#d08770;">TInt
</span><span>    parseBoolType = reserved lexer &quot;</span><span style="color:#a3be8c;">bool</span><span>&quot; &gt;&gt; return </span><span style="color:#d08770;">TBool
</span><span>    parseEnumType = </span><span style="color:#b48ead;">do
</span><span>      reserved lexer &quot;</span><span style="color:#a3be8c;">enum</span><span>&quot;
</span><span>      enumValues &lt;- brackets lexer (commaSep1 lexer (stringLiteral lexer))
</span><span>      return $ </span><span style="color:#d08770;">TEnum</span><span> enumValues
</span></code></pre>
<p>Coming from imperative programming, this function does look quite complex to me at first. But once I started to understand what was happening, I started to really like how concise these definitions are. <br />
There are no <code>if</code>s here, no <code>else if</code>s, no "<em>darn it, in this language it's <code>elif</code> not <code>else if</code></em>"'s here, which I feel like matches the more "stateless" way one would think about a grammar like the one above.</p>
<p>Remember what I said earlier about <em>monadic</em> parser combinators being overkill for this project? Well <code>parseType</code> is the one parsing function in my project that actually uses the bind operator (hidden in do notation). All other parsing functions only use <code>&gt;&gt;</code>. <br />
So maybe I was wrong earlier? Or maybe I'm wrong for using monad stuff when it's not necessary and this could be done in a purely applicative style? <br />
Well maybe at some point I'll be able to tell ^^.</p>
<h2 id="run-cabal-run"><a class="zola-anchor" href="#run-cabal-run" aria-label="Anchor link for: run-cabal-run">Run cabal, run!</a></h2>
<p>Going from the AST we've now parsed to calling the functions that modify our state is what I will refer to as <em>monkey pattern matching</em> where we can just give a decently trained ape the type signature of our function and the monkey will then do the pattern matching for us.
One might also argue that instead of apes we could use llms for such tasks.</p>
<p>Since my cognitive ability is essentially equivalent to one of those "reasoning model" thingies being used on top of a monkey's brain for token prediction, I decided to implement functions like these myself:</p>
<pre data-lang="Haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-Haskell "><code class="language-Haskell" data-lang="Haskell"><span style="color:#8fa1b3;">runParserType </span><span style="color:#b48ead;">:: Type -&gt; MetricType
</span><span>runParserType </span><span style="color:#d08770;">Parser</span><span>.</span><span style="color:#d08770;">TInt </span><span>= </span><span style="color:#d08770;">Core</span><span>.</span><span style="color:#d08770;">TInt
</span><span>runParserType </span><span style="color:#d08770;">Parser</span><span>.</span><span style="color:#d08770;">TBool </span><span>= </span><span style="color:#d08770;">Core</span><span>.</span><span style="color:#d08770;">TBool
</span><span>runParserType (</span><span style="color:#d08770;">Parser</span><span>.</span><span style="color:#d08770;">TEnum</span><span> variants) = </span><span style="color:#d08770;">Core</span><span>.</span><span style="color:#d08770;">TEnum</span><span> (fromList variants)
</span><span>
</span><span style="color:#8fa1b3;">runParserMCmd </span><span style="color:#b48ead;">:: MetricCmd -&gt; DBMonad </span><span>()
</span><span>runParserMCmd (</span><span style="color:#d08770;">Add</span><span> mname mtype) = addMetric mname (runParserType mtype)
</span></code></pre>
<p>What I found to be a lot more challenging was to now finally print stuff to stdout to build a little repl so that a user (maybe another ape?) could define some cool metrics.</p>
<p>Again, mostly because my monkey brain still can't fully handle monads, I let gemini help me with the following repl function:</p>
<pre data-lang="Haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-Haskell "><code class="language-Haskell" data-lang="Haskell"><span style="color:#8fa1b3;">executeLine </span><span style="color:#b48ead;">:: DBState -&gt; String -&gt; IO </span><span>()
</span><span>executeLine _ &quot;</span><span style="color:#a3be8c;">:q</span><span>&quot; = putStrLn &quot;</span><span style="color:#a3be8c;">Bye!</span><span>&quot;
</span><span>executeLine st &quot;</span><span style="color:#a3be8c;">:show</span><span>&quot; = </span><span style="color:#b48ead;">do
</span><span>  print st
</span><span>  repl st
</span><span>executeLine st line = </span><span style="color:#b48ead;">do
</span><span>  currentTime &lt;- getCurrentTime
</span><span>  </span><span style="color:#b48ead;">case</span><span> parse parseCmd &quot;&quot; line </span><span style="color:#b48ead;">of
</span><span>    </span><span style="color:#d08770;">Left</span><span> err -&gt; </span><span style="color:#b48ead;">do
</span><span>      print err
</span><span>      repl st
</span><span>    </span><span style="color:#d08770;">Right</span><span> cmd -&gt; </span><span style="color:#b48ead;">do
</span><span>      </span><span style="color:#b48ead;">let</span><span> result = runStateT (runParserCmd cmd currentTime) st
</span><span>      </span><span style="color:#b48ead;">case</span><span> result </span><span style="color:#b48ead;">of
</span><span>        </span><span style="color:#d08770;">Left</span><span> dbErr -&gt; </span><span style="color:#b48ead;">do
</span><span>          putStrLn $ &quot;</span><span style="color:#a3be8c;">Error: </span><span>&quot; ++ show dbErr
</span><span>          repl st
</span><span>        </span><span style="color:#d08770;">Right</span><span> (</span><span style="color:#d08770;">()</span><span>, newState) -&gt; </span><span style="color:#b48ead;">do
</span><span>          putStrLn &quot;</span><span style="color:#a3be8c;">OK</span><span>&quot;
</span><span>          repl newState
</span><span>
</span><span style="color:#8fa1b3;">repl </span><span style="color:#b48ead;">:: DBState -&gt; IO </span><span>()
</span><span>repl st = </span><span style="color:#b48ead;">do
</span><span>  putStr &quot;</span><span style="color:#a3be8c;">&gt; </span><span>&quot;
</span><span>  hFlush stdout
</span><span>  line &lt;- getLine
</span><span>  executeLine st line
</span></code></pre>
<p>This glues everything together and we get a nice little repl to track our really important data</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Welcome to TASDB. Enter commands, :show to show current state or :q to exit.
</span><span>&gt; metric add &quot;os&quot; enum [&quot;linux&quot;, &quot;evilwindowcompany&quot;]
</span><span>OK
</span><span>&gt; value insert &quot;os&quot; &quot;linux&quot;
</span><span>OK
</span><span>&gt; value insert &quot;os&quot; &quot;evilwindowcompany&quot;
</span><span>OK
</span><span>&gt; value insert &quot;foo&quot; &quot;bar&quot;
</span><span>Error: Metric &#39;foo&#39; not found
</span><span>&gt; value insert &quot;os&quot; &quot;solaris&quot;
</span><span>Error: Invalid enum value &#39;solaris&#39; for metric &#39;os&#39;. Valid options: [&quot;evilwindowcompany&quot;,&quot;linux&quot;]
</span><span>&gt; :show
</span><span>Types:
</span><span>(&quot;os&quot;,Enum [evilwindowcompany, linux])
</span><span>Values:
</span><span>(&quot;os&quot;,[&#39;evilwindowcompany&#39; - at 2025-08-28 23:12:55.999177386 UTC,&#39;linux&#39; - at 2025-08-28 23:12:47.571831704 UTC])
</span></code></pre>
<p>Of course, the printing could be prettier, but I find for how few lines of code we had to write this works quite nicely.</p>
<p>In addition, I am a lot more confident in that my little program behaves as intended, than I would likely be had I written it in an imperative language.</p>
<h2 id="what-s-next"><a class="zola-anchor" href="#what-s-next" aria-label="Anchor link for: what-s-next">What's next</a></h2>
<p>Of course there is a lot of incremental improvements to be made to our little repl tool.
More datatypes, input history (with up and down keys like in bash) and prettier printing are the first few that I can come up with on the spot.</p>
<p>However, this project was supposed to be about a database and we are not even writing anything to the disk yet - time to change that.</p>
<p>In the next part, I think I'm going to go back to the drawing board and think a little bit about how I want data to be stored.
Designing a storage backend for our database is obviously one of the most critical and challenging parts of this project, so let's look at that next.</p>
<p>As of writing this, the most recent commit on <a href="https://github.com/milanmueller/tasdb/commit/0110a09e8826029fa7e8629dcd1453dd54fab2c2">github</a> has the hash <code>0110a09</code>. Code shown here might look very different on the repo at a future point in time.</p>

            </section>
        </article>
    </main>



            
                
            

            
                <div class="giscus"></div>
                <script src="https://utteranc.es/client.js" repo="YOUR_NAME/YOUR_REPO" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
</script>

            
        </div>
    </body>

</html>
